#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in7,    infraSensor,    sensorReflection)
#pragma config(Sensor, dgtl2,  button,         sensorTouch)
#pragma config(Sensor, dgtl3,  RedLED,         sensorDigitalOut)
#pragma config(Sensor, dgtl7,  RedLED2,        sensorDigitalOut)
#pragma config(Sensor, dgtl10, sonarSensor,    sensorSONAR_cm)
#pragma config(Sensor, I2C_1,  encoder,        sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           motorRight,    tmotorVex269_HBridge, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port2,           motorLeft,     tmotorVex269_MC29, openLoop)
#pragma config(Motor,  port3,           motorClaw,     tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

const int motorDefault = 35;

const  int OFF = 0;
const  int ON  = 1;

void moveForwards(){
		motor[motorRight] = motorDefault;
		motor[motorLeft] = motorDefault;
}


void moveStop(){
	motor[motorRight] = 0;
	motor[motorLeft] = 0;
}

void turnLeft(){
		motor[motorRight] = motorDefault;
		motor[motorLeft] = -motorDefault;
}

bool button_pushed;

void monitorInput()
{
  if(SensorValue(button) && !button_pushed)
  {
    button_pushed = true;
  }

}

/*
When the robot is placed within 1 metre of the IR target, robot turns to face the
target when a button is pushed. If your robot can turn to face the target when it is
placed more than 1 metre away from the target then you will get bonus marks.
*/

//robot turns in a cirle; stops and turns on LED when infrared sensor detects IR light

const int infraSensorThreshhold = 3950;

void test1(){
		turnLeft();
		if(SensorValue[infraSensor] < infraSensorThreshhold){
			SensorValue(RedLED) = ON;
			moveStop();
			button_pushed = false;
		}
}

/*
Robot can detect when it is at proper distance and orientation with respect to the
target for object placement. Your robot should also detect when it is too far away or
too close for object placement. The robot can be manually moved during this test.

Demonstrate this with a program that will turn on an indication (example, an
LED) when the robot is too far away or too close for target drop-off. Use another
indication (example, another LED) when the robot is facing the object while at
the proper distance for drop-off.

You can use a different program to test for these conditions than the program used
for part (a) above.
*/

const int objectPlacementThreshholdUpper = 7;	//in cm
const int objectPlacementThreshholdLower = 5;	//in cm

//led 1 turns on when too far or too close for object placement
//led 2 is turned on when in right range & orientation

void test2(){
		if(objectPlacementThreshholdLower < SensorValue[sonarSensor] && SensorValue[sonarSensor] < objectPlacementThreshholdUpper){
			SensorValue(RedLED) = OFF;
			if(SensorValue[infraSensor] < infraSensorThreshhold){
				SensorValue(RedLED2) = ON;
			}else{
					SensorValue(RedLED2) = OFF;
			}
		}else{
			SensorValue(RedLED) = ON;
		}
}


/*
Detection of when the robot is about to or has encountered the arena wall.

Demonstrate this with a program in which the robot will approach a wall and
stop before touching the wall. At minimum, your robot should be able to
detect when it comes at the wall directly or at angles up to 30 degrees from
the direct approach to the wall. Your robot should not wedge itself into
corners or hit the wall in an uncontrolled fashion.

You can use a different program from that used in parts (a) and (b) above.
*/

//led 1 turns on when it comes within 25cm of a wall
//the robot will also stop when encountering a wall

const int wallThreshhold = 25;	//in cm

void test3(){
	moveForwards();
	if(SensorValue[sonarSensor] < wallThreshhold){
		SensorValue(RedLED) = ON;
		moveStop();
		button_pushed = false;
	}
	else{
		SensorValue(RedLED) = OFF;
	}
}

enum T_test{
	TEST_ONE = 0,
	TEST_TWO,
	TEST_THREE
};

T_test testNumber = TEST_ONE;	//<------------ CHANGE THIS TO SWAP WHICH PART OF THE TEST YOU ARE PERFORMING

task main()
{
	button_pushed = false;

	while (true){

		monitorInput();

		//tests only start when button is pushed

		if (button_pushed){

			SensorValue(RedLED) = OFF;
			SensorValue(RedLED2) = OFF;

			switch(testNumber){

				case(TEST_ONE):
					test1();
					break;

				case(TEST_TWO):
					test2();
					break;

				case(TEST_THREE):
					test3();
					break;

				default:
					break;
			}
		}
	}
}
