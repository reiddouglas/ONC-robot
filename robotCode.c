#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    infraSensor,    sensorReflection)
#pragma config(Sensor, dgtl7,  sonarSensor,    sensorSONAR_cm)
#pragma config(Sensor, I2C_1,  encoder,        sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           motorRight,    tmotorVex269_HBridge, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port2,           motorLeft,     tmotorVex269_MC29, openLoop)
#pragma config(Motor,  port3,           motorClaw,     tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

enum T_systemState{
	FIND_TARGET_CLOSE = 0,
	FIND_TARGET_SPIN,
	MOVE_NEW_AREA,
	PLACE_OBJECT
};

T_systemState systemState = FIND_TARGET_SPIN;

enum T_turnState{
	TURN_LEFT = 0,
	TURN_RIGHT
};

T_turnState turnState = TURN_LEFT;

const int fullTurn = 1000;
const int infraSensorThreshhold = 1000;
const int wallThreshhold = 5;
const int infraSensorCloseThreshhold = 1000;
const int objectPlacementThreshhold = 5;
const int motorDefault = 15;
int distanceSaved = 0;
int infraredSaved = 0;

task main()
{
	T_systemState systemState = FIND_TARGET_SPIN;

	resetMotorEncoder(motorRight);
}

void moveForwards(){
		motor[motorRight] = motorDefault;
		motor[motorLeft] = motorDefault;
}

void moveReverse(){
		motor[motorRight] = -motorDefault;
		motor[motorLeft] = -motorDefault;
}

void moveStop(){
	motor[motorRight] = 0;
	motor[motorLeft] = 0;
}

void turnLeft(){
		motor[motorRight] = motorDefault;
		motor[motorLeft] = -motorDefault;
}

void turnRight(){
		motor[motorRight] = -motorDefault;
		motor[motorLeft] = motorDefault;
}

void turnSlightLeft(){
		motor[motorRight] = motorDefault;
		motor[motorLeft] = motorDefault-5;
}

void turnSlightRight(){
		motor[motorRight] = motorDefault-5;
		motor[motorLeft] = motorDefault;
}

void preChangeState(){
	moveStop();
	wait1Msec(500);
	resetMotorEncoder(motorRight);
}

bool targetCheck(){
	if(SensorValue[sonarSensor] < wallThreshhold && SensorValue[infraSensor] < infraSensorCloseThreshhold){
			return true;
	}
	return false;
}

void spin(){
	if(getMotorEncoder(motorRight) < 1.25*fullTurn){
		turnLeft();
		if(SensorValue[sonarSensor] < wallThreshhold){
			moveReverse();
			wait1Msec(500);
			preChangeState();
		}
		if(SensorValue[infraSensor] > infraSensorThreshhold){
			preChangeState();
			systemState = FIND_TARGET_CLOSE;
		}
	}else{
		preChangeState();
		systemState = MOVE_NEW_AREA;
	}
}

void moveNewArea(){
	moveForwards();
	if(SensorValue[sonarSensor] < wallThreshhold){
		moveReverse();
		wait1Msec(500);
		preChangeState();
		systemState = FIND_TARGET_SPIN;
	}
	if(SensorValue[infraSensor] > infraSensorThreshhold){
		preChangeState();
		systemState = FIND_TARGET_CLOSE;
	}
}

void findTarget(){

	if(targetCheck()){
		preChangeState();
		systemState = PLACE_OBJECT;
		return;
	}
	switch(turnState){

		case(TURN_LEFT):

			turnSlightLeft();
			if(infraredSaved < SensorValue[infraSensor]){
				turnState = TURN_RIGHT;
			}else{
				infraredSaved = SensorValue[infraSensor];
			}

			case(TURN_RIGHT):

			turnSlightRight();
			if(infraredSaved < SensorValue[infraSensor]){
				turnState = TURN_LEFT;
			}else{
				infraredSaved = SensorValue[infraSensor];
			}
	}

}

void placeObject(){
		motor[motorClaw] = 10;
		wait1Msec(500);
		motor[motorClaw] = 0;
}
