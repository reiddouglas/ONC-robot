#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl1,  button1,        sensorTouch)
#pragma config(Sensor, dgtl2,  button2,        sensorTouch)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           motor1,        tmotorVex393_HBridge, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port2,           motor2,        tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port3,           motor3,        tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

bool button1_pushed; //flag to store button1 input
bool button2_pushed; //flag to store button2 input

void monitorInput()
{
	//sets button flags to true
  if(SensorValue(button1) && !button1_pushed){
    button1_pushed = true;
  }

  if(SensorValue(button2) && !button2_pushed){
    button2_pushed = true;
  }
}

/* monitorInput()
*
*  Used to flag button inputs
*       - this avoids errors caused by program recognizing input, taking action, and
*         reading input again before button is released
*/

void turn90(int magnitude){
	// Define tag for enumerated type for exercise 1
	enum T_turn90 {
			state1 = 0,	//stopped
			state2,			//turning
	};

	// Declare variable to hold state, intialize to MOTOR_STOP state.

	T_turn90 turn90 = state1;

	getMotorEncoder(motor1);

		// Switch the states.
		switch(turn90) {

			// Code for MOTOR_STOP state:
		case state1:
			if (button2_pushed == true){
			motor[motor1] = 50;
			motor[motor2] = 50;
			turn90 = state2;
			}
			break;

		case state2:
			if (abs(getMotorEncoder(motor1)) >= abs(3000*magnitude)){
				turn90 = state1;
				button2_pushed = false;
			}
			break;

		default:
			break;
	}//end switch
}//end turn90()

void moveForward(int magnitude){

	enum T_moveForward {
			state1 = 0,	//stopped
			state2,			//moving
	};

	T_moveForward forwardState = state1;

	switch(forwardState){

	case state1:
		if(button1_pushed == true){
		motor[motor1] = -25;
		motor[motor2] = 25;
		}

	case state2:
		if (abs(getMotorEncoder(motor1)) >= abs(3000)){
			motor[motor1] = 0;
			motor[motor2] = 0;
		}
	}

}

task main()
{
	button1_pushed = button2_pushed = false;

	enum T_main {
		state1 = 0,	//stopped
		state2,			//turning
		state3, 		//moving
	};

	T_main robotState = state1;
	resetMotorEncoder(motor1);

	while(true){

		// This function updates the button1_pushed and button2_pushed flags.
		switch(robotState) {

			// Code for MOTOR_STOP state:
		case state1:
			monitorInput();
			resetMotorEncoder(motor1);
			if (button2_pushed == true){
				motor[motor1] = 100;
				motor[motor2] = 60;
				robotState = state2;
			}


			else if(button1_pushed == true){
				motor[motor1] = -100;
				motor[motor2] = 60;
				robotState = state3;
			}



			/*
			else if(button1_pushed == true){
				motor[motor3] = 20;
				robotState = state3;
			}
			*/
			break;

		case state2:
			if (abs(getMotorEncoder(motor1)) >= abs(450)){
				motor[motor1] = 0;
				motor[motor2] = 0;
				button2_pushed = false;
				resetMotorEncoder(motor1);
				robotState = state1;
			}
			break;


		case state3:
			if (abs(getMotorEncoder(motor1)) >= abs(2500)){
			motor[motor1] = 0;
			motor[motor2] = 0;
			button1_pushed = false;
			resetMotorEncoder(motor1);
			robotState = state1;
		}


		/*
		case state3:
			//wait1Msec(3000);
			//motor[motor3]=-20;
			wait1Msec(3000);
			motor[motor3]=0;
			button1_pushed = false;
			robotState = state1;
		*/
		default:
		break;
		}//end switch
	}//end while
}// end main
